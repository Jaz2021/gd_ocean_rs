/*-----------------------------------------------------------------------------------------------------------
													Imports and Usings
-----------------------------------------------------------------------------------------------------------*/
using Godot;
using System;
using System.Collections.Generic;

/*-----------------------------------------------------------------------------------------------------------
													QuadTree3D Class
-----------------------------------------------------------------------------------------------------------*/
[GlobalClass]
[Icon("res://Ocean/addons/oceanfft/icons/QuadTree3D.svg")]
public partial class QuadTree : Node3D
{
	/*---------------------------------------------------------------------------------
								Variables
	----------------------------------------------------------------------------------*/

    // Specifies the LOD level of the current quad. There will be X - 1 subquad levels nested below this quad.
	[Export(PropertyHint.Range, "0,1000000,1")]
    public int LODLevel = 2;

    // Horizontal size of the current quad.
    [Export(PropertyHint.Range, "1.0,65535.0")]
    public float QuadSize = 1024.0f;

    // Morph range for CDLOD geomorph between LOD levels.
    [Export(PropertyHint.Range, "0.0,1.0,0.001")]
    public float MorphRange = 0.15f;

    // Vertex resolution of each of the quads in this tree.
    [Export(PropertyHint.Range, "0,32000,1")]
    public int MeshVertexResolution = 256;
	/*---------------------------------------------------------------------------------
							LOD Level Array
	----------------------------------------------------------------------------------*/

    // Ranges for each LOD level. Accessed as Ranges[LODLevel].
	[Export]
    public Godot.Collections.Array<float> Ranges = new() { 512.0f, 1024.0f, 2048.0f };

	// The visual shader to apply to the surface geometry.
	[Export]
	/*---------------------------------------------------------------------------------
								Variables pt 2
	----------------------------------------------------------------------------------*/

    public ShaderMaterial Material;

    // Will hold this resource loaded so as to instantiate subquads.
    // This can't currently be preloaded due to an engine bug.
    // https://github.com/godotengine/godot/issues/70985
    public PackedScene Quad;

    // Whether the current quad is the root quad in the tree. Initializes all nested subquads on ready.
    public bool IsRootQuad = true;

    // If this is true, the LOD system will be paused in its current state.
    public bool PauseCull = false;

    // The cull box that encloses this quad.
    public Aabb CullBox;

    // Meshes for each LOD level.
    
    public List<PlaneMesh> LODMeshes = new();

    // This quad's mesh instance.
    public MeshInstance3D MeshInstance;

    // Visibility detector to determine screen presence.
    private VisibleOnScreenNotifier3D visibilityDetector;

    // Subquads contained within this quad.
    private List<QuadTree> _subquads = new();

	/*---------------------------------------------------------------------------------
								_Ready Function
	----------------------------------------------------------------------------------*/

    public override void _Ready()
	{
        // Console.Log("Ready");
        Node3D subquadNode;
        MeshVertexResolution = (int)Globals.instance.oceanDetail;

        if (IsRootQuad)
		{
            LODLevel = Globals.instance.renderDistance;

			// Load self to instantiate subquads with.
			Quad = GD.Load<PackedScene>("res://Ocean/addons/oceanfft/components/QuadTree.tscn");
            
            // Set max view distance and fade range start from the current camera.
            var viewPort = GetViewport();
			if(viewPort == null){
                return;
            }
            var camera = GetViewport().GetCamera3D();
			if(camera != null){
				Material.SetShaderParameter("view_distance_max", camera.Far);
			}
			Material.SetShaderParameter("vertex_resolution", MeshVertexResolution);

			// Initialize LOD meshes for each level.
			float currentSize = QuadSize;
			for (int i = 0; i <= LODLevel; i++)
			{
				var mesh = new PlaneMesh
				{
					Size = Vector2.One * currentSize,
					SubdivideWidth = MeshVertexResolution - 1,
					SubdivideDepth = MeshVertexResolution - 1
				};
				LODMeshes.Insert(0, mesh);
				currentSize *= 0.5f;
			}

			// Create runtime components.
			MeshInstance = new MeshInstance3D();
			subquadNode = new Node3D();
			visibilityDetector = new VisibleOnScreenNotifier3D();

			AddChild(subquadNode);
			AddChild(MeshInstance);
			AddChild(visibilityDetector);
		}
		else
		{
			// Non-root quads grab their children via scene references.
			MeshInstance = GetNode<MeshInstance3D>("MeshInstance3D");
			subquadNode = GetNode<Node3D>("SubQuads");
			visibilityDetector = GetNode<VisibleOnScreenNotifier3D>("VisibleOnScreenNotifier3D");
		}

		float offsetLength = QuadSize * 0.25f;

		// Mesh configuration.
		MeshInstance.Visible = false;
		MeshInstance.Mesh = LODMeshes[LODLevel];
		MeshInstance.MaterialOverride = Material;
		MeshInstance.SetInstanceShaderParameter("patch_size", QuadSize);
		MeshInstance.SetInstanceShaderParameter("min_lod_morph_distance", Ranges[LODLevel] * 2 * (1.0f - MorphRange));
		MeshInstance.SetInstanceShaderParameter("max_lod_morph_distance", Ranges[LODLevel] * 2);

		// AABB setup for visibility/culling.
		visibilityDetector.Aabb = new Aabb(new Vector3(-QuadSize * 0.75f, -QuadSize * 0.5f, -QuadSize * 0.75f),
											new Vector3(QuadSize * 1.5f, QuadSize, QuadSize * 1.5f));
		MeshInstance.CustomAabb = visibilityDetector.Aabb;

		CullBox = new Aabb(GlobalPosition + new Vector3(-QuadSize * 0.5f, -10, -QuadSize * 0.5f),
						   new Vector3(QuadSize, 20, QuadSize));

		// If this is not the most detailed LOD level, initialize more detailed children.
		if (LODLevel > 0)
		{
			var offsets = new Vector3[]
			{
				new Vector3(1, 0, 1),
				new Vector3(-1, 0, 1),
				new Vector3(1, 0, -1),
				new Vector3(-1, 0, -1)
			};

			foreach (var offset in offsets)
			{
				var newQuad = Quad.Instantiate<QuadTree>();
				newQuad.LODLevel = LODLevel - 1;
				newQuad.QuadSize = QuadSize * 0.5f;
				newQuad.Ranges = Ranges;
				newQuad.ProcessMode = ProcessModeEnum.Disabled;
				newQuad.Position = offset * offsetLength;
				newQuad.MorphRange = MorphRange;
				newQuad.Quad = Quad;
				newQuad.LODMeshes = LODMeshes;
				newQuad.IsRootQuad = false;
				newQuad.Material = Material;

				subquadNode.AddChild(newQuad);
				_subquads.Add(newQuad);
			}
		}
	}

    // Only root quads process, subquads are set to disabled.
    public override void _Process(double delta)
    {
        if (!PauseCull && Engine.GetFramesDrawn() % 2 != 0)
        {
            var camera = GetViewport().GetCamera3D();
            LodSelect(camera.GlobalPosition);
        }
    }

    // Select which meshes will be displayed at which LOD level.
    // A return value of true marks the node as handled;
    // false indicates the parent node must handle it.
    public bool LodSelect(Vector3 camPos)
    {
        // Beginning at the root node of lowest LOD, and working towards the most detailed LOD 0.

        if (!WithinSphere(camPos, Ranges[LODLevel]))
        {
            // This quad is not within range of the selected LOD level;
            // parent will need to display this at a lower LOD.
            ResetVisibility();
            return false;
        }
        if (!visibilityDetector.IsOnScreen())
        {
            // This quad is not on screen; don't make it visible.
            MeshInstance.Visible = false;
            return true;
        }

        if (LODLevel == 0)
        {
            // At the most detailed LOD; show this quad and return handled.
            MeshInstance.Visible = true;
            return true;
        }
        else
        {
            // Still in range; check if children should render this instead.
            if (!WithinSphere(camPos, Ranges[LODLevel - 1]))
            {
                // No children are in range; this quad handles it.
                ResetVisibility();
                foreach (var subquad in _subquads)
                    subquad.MeshInstance.Visible = true;
            }
            else
            {
                // At least one more detailed child is in range; recurse.
                foreach (var subquad in _subquads)
                {
                    if (!subquad.LodSelect(camPos))
                        subquad.MeshInstance.Visible = true;
                }
            }

            return true; // Area handled.
        }
    }


	/*---------------------------------------------------------------------------------
							ResetVisibility Function
	----------------------------------------------------------------------------------*/

    // Reset this quad and all subquads to invisible.
	public void ResetVisibility()
	{
		if (MeshInstance.Visible)
		{
			MeshInstance.Visible = false;
		}
		else
		{
			foreach (var subquad in _subquads)
				subquad.ResetVisibility();
		}
	}

    // Returns true if this quad's cull_box AABB intersects with a sphere.
    public bool WithinSphere(Vector3 center, float radius)
    {
        float radiusSquared = radius * radius;
        float dmin = 0.0f;

        for (int i = 0; i < 3; i++)
        {
            float c = center[i];
            float min = CullBox.Position[i];
            float max = CullBox.End[i];

            if (c < min)
                dmin += Mathf.Pow(c - min, 2.0f);
            else if (c > max)
                dmin += Mathf.Pow(c - max, 2.0f);
        }

        return dmin <= radiusSquared;
    }
}
