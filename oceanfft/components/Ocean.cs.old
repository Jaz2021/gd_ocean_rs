using System;
using System.Linq;
using Godot;
using Godot.Collections;
[Tool]
[GlobalClass]
public partial class Ocean : Resource {
    const uint UNIFORM_SET = 0;
    const int WORK_GROUP_DIM = 32;
    const float GOLDEN_RATIO = 1.618033989f;
    enum Binding {
        SETTINGS = 0,
        INITIAL_SPECTRUM = 20,
        SPECTRUM = 21,
        PING = 25,
        PONG = 26,
        INPUT = 27,
        OUTPUT = 28,
        DISPLACEMENT = 30,
    }
    enum FFTResolution {
        FFT_2x2 = 2,
        FFT_4x4 = 4,
        FFT_8x8 = 8,
        FFT_16x16 = 16,
        FFT_32x32 = 32,
        FFT_64x64 = 64,
        FFT_128x128 = 128,
        FFT_256x256 = 256,
        FFT_512x512 = 512,
        FFT_1024x1024 = 1024,
        FFT_2048x2048 = 2048,
    }
    //  Whether _simulate() should be called by _process(). The simulation_frameskip
    //  setting will control whether this calls every frame, or skips frames. This
    //  does not affect the ability to call _simulate() directly, but it probably
    //  should be disabled if you are calling the simulation directly.
    [Export] bool simulationEnabled = true;
    // The vertex and shader that will use the generated displacement maps to deform
    // the surface geometry and apply visual shading.
    [Export] public ShaderMaterial material;
    [ExportGroup("Simulation Settings")]
    [Export(PropertyHint.Range, "0,1,0.001")]
    public float WaveMult {
        get => waveMult;
        set {
            waveMult = value;
            material?.SetShaderParameter("wave_mult", value);
        }
    }
    // ## Controls how many frames the _process() skips calling _simulate().
    // ## For a smooth visual simulation, _simulate() should be called at least 30
    // ## frames per second (FPS / (frameskip + 1) >= 30).
    // ## Set to 0 to disable frame skip.
    [Export(PropertyHint.Range, "0,30,1")] int simulationFrameskip = 0;
    // Controls how frequently _process() requests a heightmap sync when calling
    // _simulate(). This is used by the buoyancy system, high frameskip settings
    // may cause floating objects to appear disconnected from the rendered waves.
    // When used in conjunction with simulation_frameskip, this will only count
    // frames where _simulate() was called by _process().
    // Set to -1 to disable heightmap sync (breaks buoyancy).
    // Set to 0 to disable heightmap sync frame skip.
    [Export(PropertyHint.Range, "-1,30,1")] int heightmapSyncFrameskip = 0;
    int _heightmapSyncFrameskip = 0;
    // ## The resolution to generate the displacement maps at via FFT in the compute
    // ## shaders.

    FFTResolution FftResolution
    {
        get{
            return fftResolution;
        }
        set
        {
            _is_initial_spectrum_changed = true;
            fftResolution = value;
        }
    }
    [Export]
    FFTResolution fftResolution = FFTResolution.FFT_256x256;
    // ## The horizontal distance the ocean patch should be simulated for.
    [Export(PropertyHint.Range, "0,2048")] int HorizontalDimension {
        get {
            return horizontalDimension;
        }
        set {
            _is_initial_spectrum_changed = true;
            horizontalDimension = value;
        }
    }
    
    int horizontalDimension = 256;
    // The time scale for the simulation. Speeds up or slows down the waves.
    [Export(PropertyHint.Range, "0.001,5.0")] float time_scale = 1.0f;
    // The wave number ranges of the wave energy spectrum that each displacement
    // cascade covers.
    [Export] Array<Vector2> cascadeRanges = [new(0.0f, 0.03f), new(0.03f, 0.15f), new(0.15f, 1.0f)];

    // ## The UV scales applied to each displacement map cascade when applied to the
    // ## surface geometry.
    [Export] public Array<float> cascadeScales = [GOLDEN_RATIO * 2.0f, GOLDEN_RATIO, 0.5f];
    [ExportGroup("Surface Deform Modifiers")]
    // ## Reduce the height of the ocean surface exponentially as distance from the
    // ## camera increases. Simulates planetary curve.
    [Export(PropertyHint.Range, "0.0,0.001,0.0000001")]
    float PlanetaryCurveStrength {
        get {
            return planetaryCurveStrength;
        }
        set {
            planetaryCurveStrength = value;
            material?.SetShaderParameter("planetary_curve_strength", planetaryCurveStrength);
        }
    }
    float planetaryCurveStrength = 0.000001f;

    [ExportSubgroup("Amplitude Distance Fade")]
    // Amplitude scale applied to the ocean surface at amplitude_scale_fade_distance
    // from the camera.
    [Export(PropertyHint.Range, "0.0,5.0,0.01")] float AmplitudeScaleMin {
        get {
            return amplitudeScaleMin;
        }
        set {
            amplitudeScaleMin = value;
            material?.SetShaderParameter("amplitude_scale_min", amplitudeScaleMin);
        }
    }
    float amplitudeScaleMin = 0.25f;
    // ## Amplitude scale applied to the ocean surface near the camera.
    [Export(PropertyHint.Range, "0.0,5.0,0.01")] float AmplitudeScaleMax {
        get {
            return amplitudeScaleMax;
        }
        set {
            amplitudeScaleMax = value;
            material?.SetShaderParameter("amplitude_scale_max", amplitudeScaleMax);
        }
    }
    float amplitudeScaleMax = 1.0f;
    // ## Linear interpolate between amplitude_scale_min at 0 units from camera, and
    // ## amplitude_scale_max at amplitude_scale_fade_distance units from camera.
    [Export(PropertyHint.Range, "0.0,32000.0,10.0")] float AmplitudeScaleFadeDistance {
        get {
            return amplitudeScaleFadeDistance;
        }
        set {
            amplitudeScaleFadeDistance = value;
            material?.SetShaderParameter("amplitude_scale_fade_distance", amplitudeScaleFadeDistance);
        }
    }
    

    float amplitudeScaleFadeDistance = 12000.0f;
    // ## Noise texture used to domain warp the displacement maps as they are applied
    // ## to the surface.
    [ExportSubgroup("Domain Warp")]
    [Export] NoiseTexture2D DomainWarpTexture {
        get => domainWarpTexture;
        set {
            if(value == null){
                domainWarpTexture = value;
                return;
            }
            material?.SetShaderParameter("domain_warp_texture", value);
            domainWarpTexture = value;
            Action handler = null;
            handler = () => {
                WarpTextureChanged();
                value.Changed -= handler;
            };
            value.Changed += handler;
        }
    }

    private void WarpTextureChanged()
    {
        domainWarpImage = domainWarpTexture.GetImage();
    }


    NoiseTexture2D domainWarpTexture;
    // ## Controls how much distortion is applied to the displacement map domain warp
    [Export(PropertyHint.Range, "0.0,5000.0")] float DomainWarpStrength {
        get => domainWarpStrength;
        set {
            material?.SetShaderParameter("domain_warp_strength", value);
            domainWarpStrength = value;
        }
    }
    float domainWarpStrength = 1500.0f;
    // ## Controls how large the domain_warp_texture is stretched horizontally.
    // ## Smaller numbers result in more horizontal stretching.
    // ## To stretch the texture to cover X world units, set this value to 1.0 / X
    float DomainWarpUvScale {
        get => domainWarpUvScale;
        set {
            material?.SetShaderParameter("domain_warp_uv_scale", value);
            domainWarpUvScale = value;
        }
    }
    [Export(PropertyHint.Range, "0.0,1.0,0.0000001")] float domainWarpUvScale = 0.0000625f;

    [ExportGroup("Weather Settings")]
    // ## Wave choppiness value. Higher values give waves sharper crests, but can cause
    // ## wave geometry to fold in over itself.
    [Export(PropertyHint.Range, "0.0,10.0")] float choppiness = 1.5f;
    // ## The wind direction.
    float WindDirectionDegrees {
        get {
            return windDirectionDegrees;
        }
        set {
            windDirectionDegrees = Mathf.Clamp(value, 0, 360);
        }
    }
    [Export(PropertyHint.Range, "0.0,360.0")] float windDirectionDegrees = 0.0f;
    // ## Controls how much the generated displacement maps are scrolled horizontally
    // ## over time.
    [Export(PropertyHint.Range, "-10.0, 10.0")] float waveScrollSpeed = 0.0f;
    float WindSpeed {
        get => waveVector.Length();
        set {
            waveVector = waveVector.Normalized() * value;
        }
    }
    // ## The speed of the wind passed to the wave simulation.
    [Export(PropertyHint.Range, "0.0,1000.0")] float windSpeed = 300.0f;
    public bool initialized = false;
    // ## The "accumulated wind" that has blown, for wave scrolling from wind.
    // ## Updated each frame by Ocean3D._process()
    public Vector2 windUvOffset = Vector2.Zero;
    // ## The wind direction.
    float windDirection = 0.0f;
    // ## TODO: figure out what this is actually supposed to do // What do you mean open source code figure out what you do?
    Vector2 WaveVector {
        get => waveVector;
        set {
            waveVector = value;
            _is_initial_spectrum_changed = true;
        }
    }
    Vector2 waveVector = new(300.0f, 0.0f);
    public float uvScale = 0.00390625f;
    RenderingDevice _rd = RenderingServer.GetRenderingDevice();
    RDTextureFormat fmtR32f = new RDTextureFormat();
    RDTextureFormat fmtRG32f = new RDTextureFormat();
    RDTextureFormat fmtRGBA32f = new RDTextureFormat();
    Rid initialSpectrumShader;
    Rid initialSpectrumPipeline;
    bool _is_initial_spectrum_changed = true;
    Array<Rid> initialSpectrumSettingsBufferCascade = [];
    Array<RDUniform> initialSpectrumSettingsUniformCascade = [];
    Array<RDUniform> initialSpectrumUniformCascade = [];
    Array<Rid> initialSpectrumTexCascade = [];
    Rid phaseShader;
    Rid phasePipeline;
    Rid phaseSettingsBuffer;
    RDUniform phaseSettingsUniform = new();
    Array<RDUniform> pingUniformCascade = [];
    Array<RDUniform> pongUniformCascade = [];
    Array<Image> pingImageCascade = [];
    Array<Rid> pingTexCascade = [];
    Array<Rid> pongTexCascade = [];
    Rid spectrumShader;
    Rid spectrumPipeline;
    bool _is_spectrum_changed = true;
    Rid spectrumSettingsBuffer;
    RDUniform spectrumSettingsUniform = new();
    Array<RDUniform> spectrumUniformCascade = [];
    Array<Rid> spectrumTexCascade = [];
    Array<Rid> spectrumTexCascadeOld = [];

    Rid fftHorizontalShader;
    Rid fftHorizontalPipeline;
    Rid fftVerticalShader;
    Rid fftVerticalPipeline;
    Rid fftSettingsBuffer;
    RDUniform fftSettingsUniform = new();
    RDUniform subPongUniform = new();
    Rid subPongTex;
    Array<Image> wavesImageCascade = [];
    Array<Texture2Drd> wavesTextureCascadeOld = [];
    Array<Texture2Drd> wavesTextureCascade = [];
    
    bool isPingPhase = true;
    int frameskip = 0;
    // int heightmapSyncFrameskip = 0;
    float accumulatedDelta = 0f;
    public double externalTotalDelta = 0f;
    public double internalTotalDelta = 0f;
    Image domainWarpImage;
    
    private float waveMult = 1.0f;
    public RandomNumberGenerator rng = new();
    // ## Initialize the simulation
    public void InitializeSimulation(float oceanDelta){
        if(Globals.instance != null){
            Globals.instance.ocean = this;
        }
        material.SetShaderParameter("vertex_resolution", (int)Globals.instance.oceanDetail);
        material.SetShaderParameter("sim_time", oceanDelta);
        rng.Seed = Globals.instance.oceanRngSeed;
        Console.Log($"Initializing ocean with seed: {rng.Seed}");
        // rng.Randomize();
        RenderingServer.CallOnRenderThread(Callable.From(RenderInitializeSimulation));
        // initialized = true;
    }
    // Do a linear interpolation between this frame and the next
    public void EstimateSimulate(float delta){
        if(!initialized){
            // throw new System.Exception("Ocean not initialized");
            return;
        }
        if(simulationEnabled){
            material.SetShaderParameter("delta", delta);
        }
    }

    // ## Simulate a single iteration of the ocean. Respects frameskip and simulation
    // ## enabled settings.
    public void simulate(float delta) {
        if(!initialized){
            throw new System.Exception("Ocean not initialized");
        }
        if(simulationEnabled){
            material.SetShaderParameter("delta", delta);
            accumulatedDelta += delta;
            internalTotalDelta += delta;
            externalTotalDelta += delta;
            if(Mathf.Abs(internalTotalDelta - externalTotalDelta) >= 0.1f){
                accumulatedDelta += (float)(externalTotalDelta - internalTotalDelta);
                delta += (float)(externalTotalDelta - internalTotalDelta);
                internalTotalDelta = externalTotalDelta;
                Console.Log($"Syncing ocean, Delta: ${delta}", Console.MessageType.Networking);

            }
            var syncHeightmap = heightmapSyncFrameskip != -1;
            windUvOffset += new Vector2(Mathf.Cos(windDirection), Mathf.Sin(windDirection)) * waveScrollSpeed * delta;
            // Console.Log($"TotalDelta: {totalDelta}");
            if (simulationFrameskip > 0){
                frameskip++;
                if (frameskip <= simulationFrameskip){
                    return;
                }
                else {
                    frameskip = 0;
                }
            }

            material.SetShaderParameter("wind_uv_offset", windUvOffset);
            if (heightmapSyncFrameskip > 0){
                _heightmapSyncFrameskip += 1;
                if(_heightmapSyncFrameskip <= heightmapSyncFrameskip){
                    syncHeightmap = false;
                } else {
                    syncHeightmap = true;
                    _heightmapSyncFrameskip = 0;
                }
            }
            Callable c = Callable.From(() => RenderSimulate(accumulatedDelta, syncHeightmap));
            RenderingServer.CallOnRenderThread(c);
            accumulatedDelta = 0;
        }
    }
    // ## Simulate a single iteration of the ocean. Ignores frameskip and simulation
    // ## enabled settings.
    void ForceSimulate(float delta, bool syncHeightmap = false){
        Callable c = Callable.From(() => RenderSimulate(delta, syncHeightmap));
        RenderingServer.CallOnRenderThread(c);
    }
    // ## Convert a global position (on the horizontal XZ plane) to a pixel coordinate
    // ## for sampling the wave displacement texture directly. The Y coordinate is
    // ## ignored.
    Vector2I GlobalToPixel(Camera3D camera, Vector3 globalPos, int cascade, bool applyDomainWarp = true){
        // ## The order of operations in this function is dependent on the order of
        // ## operations used in the vertex shader to rotate and scale the displacement
        // ## map before applying it. Make sure to check if the vertex shader should be
        // ## updated to account for any changes made here.
        if(!initialized){
            throw new System.Exception("Ocean3D not initialized");
        }
        // ## Convert to UV coordinate
        // ## The visual shader uses the global XZ coordinates as UV
        Vector2 uv_pos = Vector2.Zero;
        uv_pos.X = globalPos.X;
        uv_pos.Y = globalPos.Z;
        // ## Apply domain warp
        if(applyDomainWarp && domainWarpImage != null){
            float linearDist = (globalPos - camera.GlobalPosition).Length();
            // ## Recursive call; note that it is called with the apply_domain_warp
            // ## parameter set to false to avoid infinite recursion.
            var basePixelPos = GlobalToPixel(camera, globalPos, cascade, false);
            Vector2 domainWarp = new(domainWarpImage.GetPixelv((Vector2I)((Vector2)basePixelPos * domainWarpUvScale)).R, domainWarpImage.GetPixelv((Vector2I)((Vector2)(-basePixelPos) * domainWarpUvScale)).R);
            domainWarp *= domainWarpStrength * (linearDist / camera.Far);
            uv_pos += domainWarp;
        }
        // ## Apply UV scale
        uv_pos *= uvScale;
        uv_pos *= 1.0f / cascadeScales[cascade];
        // ## Offset by wind scrolling
        uv_pos += windUvOffset * cascadeScales[cascade];
        // ## Normalize values to 0.0-1.0
        uv_pos.X -= Mathf.Floor(uv_pos.X);
        uv_pos.Y -= Mathf.Floor(uv_pos.Y);
        // ## Convert to pixel coordinate
        var pixel_pos = Vector2I.Zero;
        pixel_pos.X = Mathf.FloorToInt(((float)fftResolution - 1) * uv_pos.X);
        pixel_pos.Y = Mathf.FloorToInt(((float)fftResolution - 1) * uv_pos.Y);
        return pixel_pos;
    }

    // ## Query the wave height at a given location on the horizontal XZ plane. The Y
    // ## coordinate is ignored, and global position in this context is the position
    // ## relative to the oceans parent node. Since each pixel encodes both a vertical
    // ## and horizontal displacement, we need to offset the horizontal displacement 
    // ## and resample a few times to get an accurate height. The number of resample
    // ## iterations is defined by steps parameter.
    public float GetWaveHeight(Camera3D camera, Vector3 globalPos, int maxCascade = 1, int steps = 2){
        if(!initialized){
            return 0f;
        }
        Color pixel;
        pixel.G = 0;
        var xzOffset = Vector3.Zero;
        float totalHeight = 0;
        float linearDist = (globalPos - camera.GlobalPosition).Length();
        // Wave Displacements
        for (int cascade = 0; cascade < maxCascade; cascade++){
            for (int i = 0; i < steps; i++){
                var pixelPos = GlobalToPixel(camera, globalPos - xzOffset, cascade);
                pixel = wavesImageCascade[cascade].GetPixelv(pixelPos);
                xzOffset.X += pixel.R;
                xzOffset.Z += pixel.B;
            }
            totalHeight += pixel.G;
            xzOffset = Vector3.Zero;
        }
        // Wave Amplitude Distance Fade
        float amplitude_fade_range = Mathf.Clamp(linearDist, 0.0f, amplitudeScaleFadeDistance) / amplitudeScaleFadeDistance;
        totalHeight *= Mathf.Lerp(amplitudeScaleMax, amplitudeScaleMin, amplitude_fade_range);
        float curvation = planetaryCurveStrength * (Mathf.Pow(globalPos.X - camera.GlobalPosition.X, 2f) + Mathf.Pow(globalPos.Y - camera.GlobalPosition.Z, 2.0f));
        totalHeight -= curvation;
        return totalHeight * waveMult;

    }
    // ## Get the wave displacement map of a single cascade as an Image.
    // ## This returns the displacement map already cached on the CPU, it will not
    // ## call _simulate(), or marshall additional data from the GPU.
    Image GetWaves(int cascade = 0)
    {
        if(!initialized){
            throw new System.Exception("Ocean3D not initialized");
        }
        return wavesImageCascade[cascade];
    }
    // ## Get the wave displacement map of a single cascade as a Texture2DRD.
    Texture2Drd GetWavesTexture(int cascade = 0){
        if(!initialized){
            throw new System.Exception("Ocean3D not initialized");
        }
        return wavesTextureCascade[cascade];
    }
    // ## Get the wave displacement maps of all cascades as an Array of Images.
    // ## This returns the displacement map already cached on the CPU, it will not
    // ## call _simulate(), or marshall additional data from the GPU.
    Array<Image> GetAllWaves(){
        if(!initialized){
            throw new System.Exception("Ocean3D is not initialized");
        }
        return wavesImageCascade;
    }
    // ## Get the wave displacement maps of all cascades as an Array of Texture2DRDs.
    public Array<Texture2Drd> GetAllWavesTextures()
    {
        if(!initialized){
            // throw new System.Exception("Ocean3d not initialized");
            return null;
        }
        return wavesTextureCascade;
    }
    private byte[] PackInitialSpectrumSettings(int cascade)
    {
        // Convert int32 values
        int[] intArray = 
        {
            (int)fftResolution,
            (int)(horizontalDimension * cascadeScales[cascade])
        };
        
        // Convert float32 values
        float[] floatArray =
        {
            cascadeRanges[cascade].X,
            cascadeRanges[cascade].Y,
            waveVector.X,
            waveVector.Y
        };
        byte[] settingsBytes = new byte[(intArray.Length * 4) + (floatArray.Length * 4)];
        System.Buffer.BlockCopy(intArray, 0, settingsBytes, 0, intArray.Length * 4);
        System.Buffer.BlockCopy(floatArray, 0, settingsBytes, intArray.Length * 4, floatArray.Length * 4);
        return settingsBytes;
    }
    private byte[] PackPhaseSettings(float deltaTime, int cascade)
    {
        int[] intArray =
        {
            (int)fftResolution,
            (int)(horizontalDimension * cascadeScales[cascade])
        };
        float[] floatArray = { deltaTime };
        byte[] settingsBytes = new byte[(intArray.Length * 4) + (floatArray.Length * 4)];
        System.Buffer.BlockCopy(intArray, 0, settingsBytes, 0, intArray.Length * 4);
        System.Buffer.BlockCopy(floatArray, 0, settingsBytes, intArray.Length * 4, floatArray.Length * 4);
        return settingsBytes;
    }

    private byte[] PackSpectrumSettings(int cascade)
    {
        int[] intArray =
        {
            (int)(horizontalDimension * cascadeScales[cascade])
        };
        float[] floatArray =
        {
            choppiness,
            (float)fftResolution
        };
        byte[] settingsBytes = new byte[(intArray.Length * 4) + (floatArray.Length * 4)];
        System.Buffer.BlockCopy(intArray, 0, settingsBytes, 0, intArray.Length * 4);
        System.Buffer.BlockCopy(floatArray, 0, settingsBytes, intArray.Length * 4, floatArray.Length * 4);
        return settingsBytes;
    }
    private byte[] PackFftSettings(int subseqCount)
    {
        int[] intArray =
        {
            (int)fftResolution,
            subseqCount
        };
        byte[] settingsBytes = new byte[intArray.Length * 4];
        System.Buffer.BlockCopy(intArray, 0, settingsBytes, 0, intArray.Length * 4);
        return settingsBytes;
    }
    // #### Render Thread Code
    // ################################################################################
    // ## All code below this point must be run on the main render thread via
    // ## RenderingServer.call_on_render_thread().


    // ## Initialize the ocean simulation. Compiles shaders, prepares texture and
    // ## settings buffers.
    // ## This must be called via RenderingServer.call_on_render_thread().
    private void RenderInitializeSimulation()
    {
        RDShaderFile shaderFile;
        byte[] settingsBytes;

        var initialImageRf = Image.CreateEmpty((int)fftResolution, (int)fftResolution, false, Image.Format.Rf);
        var initialImageRgf = Image.CreateEmpty((int)fftResolution, (int)fftResolution, false, Image.Format.Rgf);

        // Initialize RDTextureFormats
        fmtR32f.Width = (uint)fftResolution;
        fmtR32f.Height = (uint)fftResolution;
        fmtR32f.Format = RenderingDevice.DataFormat.R32Sfloat;
        fmtR32f.UsageBits = RenderingDevice.TextureUsageBits.SamplingBit |
                            RenderingDevice.TextureUsageBits.CanUpdateBit |
                            RenderingDevice.TextureUsageBits.StorageBit |
                            RenderingDevice.TextureUsageBits.CanCopyFromBit;

        fmtRG32f.Width = (uint)fftResolution;
        fmtRG32f.Height = (uint)fftResolution;
        fmtRG32f.Format = RenderingDevice.DataFormat.R32G32Sfloat;
        fmtRG32f.UsageBits = fmtR32f.UsageBits;

        fmtRGBA32f.Width = (uint)fftResolution;
        fmtRGBA32f.Height = (uint)fftResolution;
        fmtRGBA32f.Format = RenderingDevice.DataFormat.R32G32B32A32Sfloat;
        fmtRGBA32f.UsageBits = fmtR32f.UsageBits;

        // Compile & Initialize Initial Spectrum Shader
        shaderFile = GD.Load<RDShaderFile>("res://addons/oceanfft/shaders/InitialSpectrum.glsl");
        initialSpectrumShader = _rd.ShaderCreateFromSpirV(shaderFile.GetSpirV());
        initialSpectrumPipeline = _rd.ComputePipelineCreate(initialSpectrumShader);

        initialSpectrumSettingsBufferCascade.Resize(cascadeRanges.Count);
        initialSpectrumSettingsUniformCascade.Resize(cascadeRanges.Count);
        initialSpectrumTexCascade.Resize(cascadeRanges.Count);
        initialSpectrumUniformCascade.Resize(cascadeRanges.Count);

        for (int i = 0; i < cascadeRanges.Count; i++)
        {
            settingsBytes = PackInitialSpectrumSettings(i);
            initialSpectrumSettingsBufferCascade[i] = _rd.StorageBufferCreate((uint)settingsBytes.Count(), settingsBytes);

            initialSpectrumSettingsUniformCascade[i] = new RDUniform
            {
                UniformType = RenderingDevice.UniformType.StorageBuffer,
                Binding = (int)Binding.SETTINGS
            };
            initialSpectrumSettingsUniformCascade[i].AddId(initialSpectrumSettingsBufferCascade[i]);

            initialSpectrumTexCascade[i] = _rd.TextureCreate(fmtR32f, new RDTextureView(), [ initialImageRf.GetData()]);
            initialSpectrumUniformCascade[i] = new RDUniform
            {
                UniformType = RenderingDevice.UniformType.Image,
                Binding = (int)Binding.INITIAL_SPECTRUM
            };
            initialSpectrumUniformCascade[i].AddId(initialSpectrumTexCascade[i]);
        }

        // Compile & Initialize Phase Shader
        shaderFile = GD.Load<RDShaderFile>("res://addons/oceanfft/shaders/Phase.glsl");
        phaseShader = _rd.ShaderCreateFromSpirV(shaderFile.GetSpirV());
        phasePipeline = _rd.ComputePipelineCreate(phaseShader);

        pingUniformCascade.Resize(cascadeRanges.Count);

        pongUniformCascade.Resize(cascadeRanges.Count);
        pingImageCascade.Resize(cascadeRanges.Count);
        pingTexCascade.Resize(cascadeRanges.Count);
        pongTexCascade.Resize(cascadeRanges.Count);

        settingsBytes = PackPhaseSettings(0.0f, 0);
        phaseSettingsBuffer = _rd.StorageBufferCreate((uint)settingsBytes.Length, settingsBytes);
        phaseSettingsUniform.UniformType = RenderingDevice.UniformType.StorageBuffer;
        phaseSettingsUniform.Binding = (int)Binding.SETTINGS;
        phaseSettingsUniform.AddId(phaseSettingsBuffer);

        // Initialize Ping Pong Buffers
        float[] pingData = new float[(int)fftResolution * (int)fftResolution];
        for (int i = 0; i < (int)fftResolution * (int)fftResolution; i++)
        {
            pingData[i] = ((float)(rng.RandfRange(0.0f, 1.0f) * 2.0 * Mathf.Pi));
            // pingData[i] = 0.5f * 2.0f * Mathf.Pi;

        }

        for (int cascade = 0; cascade < cascadeRanges.Count; cascade++)
        {
            byte[] pingByteArray = new byte[pingData.Length * 4];
            System.Buffer.BlockCopy(pingData, 0, pingByteArray, 0, pingByteArray.Length);
            pingImageCascade[cascade] = Image.CreateFromData((int)fftResolution, (int)fftResolution, false, Image.Format.Rf, pingByteArray);
            pingTexCascade[cascade] = _rd.TextureCreate(fmtR32f, new RDTextureView(), [pingImageCascade[cascade].GetData() ]);
            pingUniformCascade[cascade] = new RDUniform
            {
                UniformType = RenderingDevice.UniformType.Image,
                Binding = (int)Binding.PING
            };
            pingUniformCascade[cascade].AddId(pingTexCascade[cascade]);

            pongTexCascade[cascade] = _rd.TextureCreate(fmtR32f, new RDTextureView(), [initialImageRf.GetData() ]);
            pongUniformCascade[cascade] = new RDUniform
            {
                UniformType = RenderingDevice.UniformType.Image,
                Binding = (int)Binding.PONG
            };
            pongUniformCascade[cascade].AddId(pongTexCascade[cascade]);
        }

        // Compile & Initialize Spectrum Shader
        shaderFile = GD.Load<RDShaderFile>("res://addons/oceanfft/shaders/Spectrum.glsl");
        spectrumShader = _rd.ShaderCreateFromSpirV(shaderFile.GetSpirV());
        spectrumPipeline = _rd.ComputePipelineCreate(spectrumShader);

        settingsBytes = PackSpectrumSettings(0);
        spectrumSettingsBuffer = _rd.StorageBufferCreate((uint)settingsBytes.Count(), settingsBytes);
        spectrumSettingsUniform.UniformType = RenderingDevice.UniformType.StorageBuffer;
        spectrumSettingsUniform.Binding = (int)Binding.SETTINGS;
        spectrumSettingsUniform.AddId(spectrumSettingsBuffer);

        spectrumTexCascade.Resize(cascadeRanges.Count);
        spectrumTexCascadeOld.Resize(cascadeRanges.Count);
        spectrumUniformCascade.Resize(cascadeRanges.Count);
        wavesImageCascade.Resize(cascadeRanges.Count);
        wavesTextureCascade.Resize(cascadeRanges.Count);
        Console.Log($"Cascade Ranges count: {cascadeRanges.Count}");
        for (int i = 0; i < cascadeRanges.Count; i++)
        {
            Console.Log($"Cascade {i}");
            spectrumTexCascade[i] = _rd.TextureCreate(fmtRG32f, new RDTextureView(), [initialImageRgf.GetData() ]);
            spectrumUniformCascade[i] = new RDUniform
            {
                UniformType = RenderingDevice.UniformType.Image,
                Binding = (int)Binding.SPECTRUM
            };
            spectrumUniformCascade[i].AddId(spectrumTexCascade[i]);
            Console.Log($"Cascade {i}");

            wavesImageCascade[i] = Image.CreateEmpty((int)fftResolution, (int)fftResolution, false, Image.Format.Rgf);
            wavesTextureCascade[i] = new Texture2Drd
            {
                TextureRdRid = spectrumTexCascade[i]
            };
        }
        Console.Log("out of cascades");
        material.SetShaderParameter("cascade_displacements", wavesTextureCascade);
        material.SetShaderParameter("cascade_displacements_old", wavesTextureCascadeOld);

        material.SetShaderParameter("cascade_uv_scales", cascadeScales);
        material.SetShaderParameter("uv_scale", uvScale);

        // Compile & Initialize FFT Shaders
        shaderFile = GD.Load<RDShaderFile>("res://addons/oceanfft/shaders/FFTHorizontal.glsl");
        fftHorizontalShader = _rd.ShaderCreateFromSpirV(shaderFile.GetSpirV());
        fftHorizontalPipeline = _rd.ComputePipelineCreate(fftHorizontalShader);

        shaderFile = GD.Load<RDShaderFile>("res://addons/oceanfft/shaders/FFTVertical.glsl");
        fftVerticalShader = _rd.ShaderCreateFromSpirV(shaderFile.GetSpirV());
        fftVerticalPipeline = _rd.ComputePipelineCreate(fftVerticalShader);

        settingsBytes = PackFftSettings(0);
        fftSettingsBuffer = _rd.StorageBufferCreate((uint)settingsBytes.Count(), settingsBytes);
        fftSettingsUniform.UniformType = RenderingDevice.UniformType.StorageBuffer;
        fftSettingsUniform.Binding = (int)Binding.SETTINGS;
        fftSettingsUniform.AddId(fftSettingsBuffer);

        subPongTex = _rd.TextureCreate(fmtRG32f, new RDTextureView(), [initialImageRgf.GetData() ]);
        subPongUniform.UniformType = RenderingDevice.UniformType.Image;
        subPongUniform.AddId(subPongTex);

        initialized = true;
        Console.Log("Ocean initialized");
    }

    // ## Simulate a single iteration of the ocean. The resulting displacement map
    // ## texture can be retrieved using the get_waves_texture() function, or as an
    // ## Image via get_waves(). The texture is the same buffer in VRAM the compute
    // ## shaders operate on. The image is stored in CPU RAM and is only updated when
    // ## sync_heightmap is true.
    // ## This must be called via RenderingServer.call_on_render_thread().
    void RenderSimulate(float delta, bool sync_heightmap){
        Rid uniform_set;
        long compute_list;
        byte[] settings_bytes;
        // #### Iterate & Execute Cascades
        // ############################################################################
        
        for (int cascade = 0; cascade < cascadeRanges.Count; cascade++){
            // #### Update Initial Spectrum
            // ########################################################################
            // ## Only executed on first frame, or if Wind, FFT Resolution, or
            // ## Horizontal Dimension inputs are changed, as the output is constant
            // ## for a given set of inputs. The Initial Spectrum is cached in VRAM. It
            // ## is not returned to CPU RAM.
            if (_is_initial_spectrum_changed){
                // ## Update Settings Buffer
                settings_bytes = PackInitialSpectrumSettings(cascade);
                if (_rd.BufferUpdate(initialSpectrumSettingsBufferCascade[cascade], 0, (uint)settings_bytes.Count(), settings_bytes) != Error.Ok){
                    GD.Print("error updating initial spectrum settings buffer"); // This isn't a console.log because I don't trust it here
                }
                // ## Build Uniform Set
                uniform_set = _rd.UniformSetCreate([
                        initialSpectrumSettingsUniformCascade[cascade],
                        initialSpectrumUniformCascade[cascade]], initialSpectrumShader, (uint)UNIFORM_SET);

                // ## Create Compute List
                compute_list = _rd.ComputeListBegin();
                _rd.ComputeListBindComputePipeline(compute_list, initialSpectrumPipeline);
                _rd.ComputeListBindUniformSet(compute_list, uniform_set, (uint)UNIFORM_SET);
                _rd.ComputeListDispatch(compute_list, (uint)fftResolution / WORK_GROUP_DIM, (uint)fftResolution / WORK_GROUP_DIM, 1);
                _rd.ComputeListEnd();

                _rd.FreeRid(uniform_set);
            }
            // ## Prevent this from running again until the Wind, FFT Resolution, or
            // ## Horizontal Dimension inputs are changed. The condition ensures it
            // ## runs for all cascades.
            if (cascade == cascadeRanges.Count - 1){
                _is_initial_spectrum_changed = false;
            }
            // #### Execute Phase Shader; Updates Ping Pong Buffers
            // ########################################################################

            // ## Leave the textures in place in VRAM, and just switch the binding
            // ## points.
            if (isPingPhase)
            {
                pingUniformCascade[cascade].Binding = (int)Binding.PING;
                pongUniformCascade[cascade].Binding = (int)Binding.PONG;
            }

            else
            {
                pingUniformCascade[cascade].Binding = (int)Binding.PONG;
                pongUniformCascade[cascade].Binding = (int)Binding.PING;
            }
            // ## Update Settings Buffer
            settings_bytes = PackPhaseSettings(delta * time_scale, cascade);
            if (_rd.BufferUpdate(phaseSettingsBuffer, 0, (uint)settings_bytes.Length, settings_bytes) != Error.Ok){
                GD.Print("error updating phase settings buffer");
            }
            // ## Build Uniform Set
            uniform_set = _rd.UniformSetCreate([
                    phaseSettingsUniform,
                    pingUniformCascade[cascade],
                    pongUniformCascade[cascade]], phaseShader, (uint)UNIFORM_SET);
            // ## Create Compute List
            compute_list = _rd.ComputeListBegin();
            _rd.ComputeListBindComputePipeline(compute_list, phasePipeline);
            _rd.ComputeListBindUniformSet(compute_list, uniform_set, (uint)UNIFORM_SET);
            _rd.ComputeListDispatch(compute_list, (uint)fftResolution / WORK_GROUP_DIM, (uint)fftResolution / WORK_GROUP_DIM, 1);
            _rd.ComputeListEnd();
            _rd.FreeRid(uniform_set);
            // #### Execute Spectrum Shader Cascades
            // ########################################################################

            // ## Update Settings Buffer
            settings_bytes = PackSpectrumSettings(cascade);
            if (_rd.BufferUpdate(spectrumSettingsBuffer, 0, (uint)settings_bytes.Length, settings_bytes) != Error.Ok){
                GD.Print("error updating spectrum settings buffer");
            }
            // ## Ensure the Spectrum texture binding is correct from previous frames.
            // ## It gets changed later on in _simulate().
            spectrumUniformCascade[cascade].Binding = (int)Binding.SPECTRUM;
            // ## Build Uniform Set
            uniform_set = _rd.UniformSetCreate([
                    spectrumSettingsUniform,
                    initialSpectrumUniformCascade[cascade],
                    spectrumUniformCascade[cascade],
                    pingUniformCascade[cascade],
                    pongUniformCascade[cascade]], spectrumShader, (uint)UNIFORM_SET);
            // ## Create Compute List
            compute_list = _rd.ComputeListBegin();
            _rd.ComputeListBindComputePipeline(compute_list, spectrumPipeline);
            _rd.ComputeListBindUniformSet(compute_list, uniform_set, (uint)UNIFORM_SET);
            _rd.ComputeListDispatch(compute_list, (uint)fftResolution / WORK_GROUP_DIM, (uint)fftResolution / WORK_GROUP_DIM, 1);
            _rd.ComputeListEnd();

            _rd.FreeRid(uniform_set);
            // #### Execute Horizontal FFT Shader Cascades
            // ########################################################################
            bool isSubPingPhase = true;
            var p = 1;

            while (p < (int)fftResolution)
            {
                // ## Leave the textures in place in VRAM, and just switch the binding
                // ## points.
                if (isSubPingPhase)
                {
                    spectrumUniformCascade[cascade].Binding = (int)Binding.INPUT;
                    subPongUniform.Binding = (int)Binding.OUTPUT;
                }


                else{
                    spectrumUniformCascade[cascade].Binding = (int)Binding.OUTPUT;
                    subPongUniform.Binding = (int)Binding.INPUT;
                }
                // ## Update Settings Buffer
                settings_bytes = PackFftSettings(p);
                if (_rd.BufferUpdate(fftSettingsBuffer, 0, (uint)settings_bytes.Length, settings_bytes) != Error.Ok){
                    GD.Print("error updating horizontal FFT settings buffer");
                }
                // ## Build Uniform Set
                uniform_set = _rd.UniformSetCreate([
                        fftSettingsUniform,
                        subPongUniform,
                        spectrumUniformCascade[cascade]], fftHorizontalShader, UNIFORM_SET);

                // ## Create Compute List
                compute_list = _rd.ComputeListBegin();
                _rd.ComputeListBindComputePipeline(compute_list, fftHorizontalPipeline);
                _rd.ComputeListBindUniformSet(compute_list, uniform_set, UNIFORM_SET);
                _rd.ComputeListDispatch(compute_list, (uint)fftResolution, 1, 1);
                _rd.ComputeListEnd();


                _rd.FreeRid(uniform_set);


                p <<= 1;
                isSubPingPhase = !isSubPingPhase;
            }
            // #### Execute Vertical FFT Shader Cascades
            // ########################################################################

            p = 1;
            while (p < (int)fftResolution){
                // ## Leave the textures in place in VRAM, and just switch the binding
                // ## points.
                if (isSubPingPhase){
                    spectrumUniformCascade[cascade].Binding = (int)Binding.INPUT;
                    subPongUniform.Binding = (int)Binding.OUTPUT;
                }
                else{
                    spectrumUniformCascade[cascade].Binding = (int)Binding.OUTPUT;
                    subPongUniform.Binding = (int)Binding.INPUT;
                }
                // ## Update Settings Buffer
                settings_bytes = PackFftSettings(p);
                if (_rd.BufferUpdate(fftSettingsBuffer, 0, (uint)settings_bytes.Length, settings_bytes) != Error.Ok){
                    GD.Print("error updating vertical FFT settings buffer");
                }
                // ## Build Uniform Set
                uniform_set = _rd.UniformSetCreate([
                        fftSettingsUniform,
                        subPongUniform,
                        spectrumUniformCascade[cascade]], fftVerticalShader, UNIFORM_SET);

                // ## Create Compute List
                compute_list = _rd.ComputeListBegin();
                _rd.ComputeListBindComputePipeline(compute_list, fftVerticalPipeline);
                _rd.ComputeListBindUniformSet(compute_list, uniform_set, UNIFORM_SET);
                _rd.ComputeListDispatch(compute_list, (uint)fftResolution, 1, 1);
                _rd.ComputeListEnd();

                _rd.FreeRid(uniform_set);

                p <<= 1;
                isSubPingPhase = !isSubPingPhase;

                // ## Retrieve the displacement map from the Spectrum texture, and store it
                // ## CPU side for use by buoyancy and wave interaction systems.
                if (sync_heightmap){
                    wavesImageCascade[cascade].SetData((int)fftResolution, (int)fftResolution, false, Image.Format.Rgf, _rd.TextureGetData(spectrumTexCascade[cascade], 0));
                }
                // ## This needs to get updated outside the cascade iteration loop
                isPingPhase = !isPingPhase;
            }
        }
        for (int cascade = 0; cascade < cascadeRanges.Count; cascade++)
        {
            var oldData = _rd.TextureGetData(wavesTextureCascadeOld[cascade].TextureRdRid, 0);
            var currentData = _rd.TextureGetData(spectrumTexCascade[cascade], 0);
            
            // Check if they're different
            bool same = oldData.SequenceEqual(currentData);
            Console.Log($"Cascade {cascade}: Old and current textures are same: {same}");
        }
        for (int cascade = 0; cascade < cascadeRanges.Count; cascade++)
        {
            // Copy current texture data to old texture before updating
            var currentData = _rd.TextureGetData(spectrumTexCascade[cascade], 0);
            _rd.TextureUpdate(wavesTextureCascadeOld[cascade].TextureRdRid, 0, currentData);
        }

    }
}
